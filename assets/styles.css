/* dining-card.js — Dining Venues card (v2.244)
   - Canonical-first JSON fetch
   - Robust ship matching
   - Replaces intro copy
   - Venue names link to restaurants page anchors: /restaurants.html#<provider>-<slug>
*/
(() => {
  const CARD = document.querySelector('#dining-card');
  if (!CARD) return;

  const SOURCES = [
    'https://www.cruisinginthewake.com/assets/data/rc-restaurants.json',
    'https://www.cruisinginthewake.com/assets/data/ccl-restaurants.json',
    'https://www.cruisinginthewake.com/assets/data/msc-restaurants.json',
    '/assets/data/rc-restaurants.json','/assets/data/ccl-restaurants.json','/assets/data/msc-restaurants.json'
  ];

  // Inline config (provider, json, ship_slug, aliases)
  const cfgHook = document.getElementById('dining-data-source');
  const CFG = (() => { try { return JSON.parse(cfgHook?.textContent||'{}'); } catch { return {}; } })();
  const provider = (CFG.provider || 'rcl').toLowerCase();
  const customJson = CFG.json || '';
  const shipSlug = (CFG.ship_slug || '').toLowerCase();
  const aliases = (CFG.aliases || []).map(s => (s||'').toLowerCase());

  const DISPLAY = (CARD.getAttribute('data-ship') || document.title.replace(/—.*/, '') || '').trim();
  const DISPLAY_N = DISPLAY.toLowerCase();

  const norm = s => String(s||'').toLowerCase().replace(/’/g,"'").trim();
  const normShip = s => norm(s).replace(/\s+of the seas$/,''); // RC tolerance

  async function fetchFirst(urls){
    let lastErr;
    const list = customJson ? [customJson, ...urls] : urls;
    for (const url of list){
      try{ const r = await fetch(url, { credentials:'omit' }); if (!r.ok) throw new Error(r.status);
        const json = await r.json(); return { json, url }; }
      catch(e){ lastErr = e; }
    }
    throw lastErr || new Error('All data sources failed');
  }

  function* iterShips(root){
    if (!root) return;
    if (Array.isArray(root)) { for (const it of root) yield it; return; }
    const buckets = [root.ships, root.brands, root.lines, root.royal, root.rcl, root[provider]];
    for (const b of buckets){
      if (!b) continue;
      if (Array.isArray(b)) { for (const it of b) yield it; }
      else if (typeof b === 'object'){ for (const k of Object.keys(b)){ const v=b[k]; if (v) yield v; } }
    }
    for (const k of Object.keys(root)){
      const v = root[k];
      if (v && typeof v === 'object' && (v.name||v.title||v.ship||v.dining||v.Included||v.Premium)) yield v;
    }
  }

  const idFrom = o => ({ name:o?.name||o?.title||o?.ship||'', slug:o?.slug||o?.id||o?.key||'' });

  function pullDining(obj){
    const d = obj?.dining || obj?.venues || obj || {};
    const inc = d.included || d.complimentary || d.Included || d.Complimentary || [];
    const pre = d.premium || d.specialty || d.Premium || d.Specialty || d['Extra'] || d.extra || [];
    if (!inc.length && !pre.length && Array.isArray(d)){
      const INC=[], PRE=[];
      d.forEach(v=>{
        const label = (typeof v === 'string') ? v.trim() : (v?.name || v?.title || '').trim();
        const t = (typeof v === 'string') ? '' : (v.type||'').toLowerCase();
        if (!label) return;
        if (t.includes('prem') || t.includes('spec') || v.fee===true) PRE.push(label); else INC.push(label);
      });
      return { inc:INC, pre:PRE };
    }
    return { inc:[...inc], pre:[...pre] };
  }

  function uniqueSorted(list){
    const seen = new Set();
    return (list||[])
      .map(v => typeof v === 'string' ? v.trim() : (v?.name || v?.title || '').trim())
      .filter(Boolean)
      .filter(v => { const k = norm(v); if (seen.has(k)) return false; seen.add(k); return true; })
      .sort((a,b)=> a.localeCompare(b, undefined, { sensitivity:'base' }));
  }

  function slugify(s){ return String(s||'').toLowerCase().replace(/&/g,'and').replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,''); }

  function linkify(arr){
    const base = `/restaurants.html#${provider}-`;
    return arr.map(v => `<a href="${base}${slugify(v)}">${v}</a>`);
  }

  function renderOK(shipLabel, inc, pre){
    const intro = `
      <p class="tiny" style="margin-top:.25rem">
        Set sail through a world of flavors on board, where complimentary main dining and casual bites keep your voyage fueled,
        while premium specialty restaurants offer exclusive culinary adventures worth charting a course for.
      </p>
    `;
    const block = (title, arr, id) => `
      <section class="venue-block" aria-labelledby="${id}">
        <h3 id="${id}">${title} <span class="count" aria-hidden="true">(${arr.length})</span></h3>
        ${arr.length ? `<ul class="venue-list">${linkify(arr).map(a=>`<li>${a}</li>`).join('')}</ul>` : `<p class="tiny">No ${title.toLowerCase()} listed yet.</p>`}
      </section>`;

    document.getElementById('dining-content').innerHTML =
      intro + `<div class="venues two-col">${block('Included (Complimentary)', inc, 'incHeading')}${block('Premium (Specialty / Extra Charge)', pre, 'preHeading')}</div>`;
    CARD.removeAttribute('aria-busy');
  }

  function renderError(msg){
    document.getElementById('dining-content').innerHTML = `<p class="tiny" role="alert">${msg}</p>`;
    CARD.removeAttribute('aria-busy');
  }

  (async function init(){
    CARD.setAttribute('aria-busy','true');
    try{
      const { json } = await fetchFirst(SOURCES);
      let best=null, bestScore=-1;
      for (const cand of iterShips(json)){
        const { name, slug } = idFrom(cand);
        const nName = normShip(name);
        const nSlug = norm(slug);
        const score =
          (shipSlug && nSlug && nSlug===shipSlug) ? 3 :
          (DISPLAY_N && nName && (nName===normShip(DISPLAY_N) || aliases.includes(nName))) ? 2 : 0;
        if (score>bestScore){ best=cand; bestScore=score; if (score===3) break; }
      }
      if (!best){ renderError(`No dining record found for “${DISPLAY}”.`); return; }

      const pulled = pullDining(best);
      const inc = uniqueSorted(pulled.inc);
      const pre = uniqueSorted(pulled.pre);
      renderOK(DISPLAY, inc, pre);
    }catch(err){
      renderError(`Could not load dining data (${err?.message || err}).`);
    }
  })();
})();
