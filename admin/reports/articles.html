<script>
(function(){
  "use strict";

  const ORIGIN = (location.origin || (location.protocol + "//" + location.host));
  const MANIFEST_URL = "/precache-manifest.json";
  const SITEMAP_URL  = "/solo/sitemap.xml";
  const SITEMAP_UPDATE_ENDPOINT = ""; // optional, leave blank to disable

  // ---- helpers to get/make cards if missing ----
  function needCard(id, title, desc, cls){
    let card = document.getElementById(id);
    if (card) return card;
    const grid = document.querySelector(".grid-3-tight") || document.querySelector(".cards.stack");
    card = document.createElement("article");
    card.className = "card " + (cls||"");
    card.id = id;
    card.style.display = "none";
    card.innerHTML = `<h3>${title}</h3><p>${desc}</p><div class="scroll"><ol id="${id}-list" class="list"></ol></div>`;
    grid && grid.appendChild(card);
    return card;
  }
  function show(node){ node.style.display = ""; }
  function setDiag(msg){ document.getElementById("diag").textContent = msg; }
  function li(ol, html){ const li=document.createElement("li"); li.innerHTML=html; ol.appendChild(li); }

  // fetchers
  async function fetchJson(url){
    const r = await fetch(url, { cache:"no-store" });
    if (!r.ok) throw new Error("HTTP " + r.status + " for " + url);
    return r.json();
  }
  async function fetchText(url){
    const r = await fetch(url, { cache:"no-store" });
    if (!r.ok) throw new Error("HTTP " + r.status + " for " + url);
    return r.text();
  }
  async function exists(url){
    try{
      const r = await fetch(url, { cache:"no-store", redirect:"follow" });
      return r.ok;
    }catch(_){ return false; }
  }

  // manifest normalization
  function flattenManifestUrls(m){
    if (Array.isArray(m)) {
      return m.map(x => typeof x === "string" ? x : (x && (x.url || x.href))).filter(Boolean);
    }
    if (!m || typeof m !== "object") return [];
    const out = [];
    ["pages","assets","images","sitemaps","urls","files"].forEach(k=>{
      if (Array.isArray(m[k])) m[k].forEach(v => out.push(typeof v === "string" ? v : (v && (v.url || v.href))));
    });
    return out.filter(Boolean);
  }
  function slugsFromManifest(list, prefix){
    const out = new Set();
    for (const u of list) {
      try{
        const url = new URL(u, ORIGIN);
        const p = url.pathname;
        if (!p.startsWith(prefix)) continue;
        if (!/\.html$/i.test(p)) continue;
        const slug = p.split("/").pop().replace(/\.html$/i,"");
        if (slug && slug !== "solo" && slug !== "sitemap") out.add(slug);
      }catch(_){}
    }
    return out;
  }
  function slugsFromSitemap(xml){
    const out = new Set();
    try{
      const dom = new DOMParser().parseFromString(xml, "application/xml");
      const locs = Array.from(dom.querySelectorAll("url > loc")).map(n=>n.textContent.trim());
      for (const loc of locs) {
        try{
          const u = new URL(loc);
          if (!/\/solo\/[^/]+\.html$/i.test(u.pathname)) continue;
          const slug = u.pathname.split("/").pop().replace(/\.html$/i,"");
          if (slug && slug !== "solo") out.add(slug);
        }catch(_){}
      }
    }catch(_){}
    return out;
  }

  function fmt(mono){ return `<span class="mono">${mono}</span>`; }

  run().catch(err => setDiag("Hard failure: " + (err?.message || String(err))));

  async function run(){
    setDiag("Fetching manifest & sitemap…");

    const [man, sm] = await Promise.allSettled([ fetchJson(MANIFEST_URL), fetchText(SITEMAP_URL) ]);

    const manifestUrls = (man.status === "fulfilled") ? flattenManifestUrls(man.value) : [];
    const manifestOk   = manifestUrls.length > 0;

    const site = (sm.status === "fulfilled") ? slugsFromSitemap(sm.value) : new Set();
    const sitemapOk = (sm.status === "fulfilled");

    // From manifest, treat these separately
    const mPages = manifestOk ? slugsFromManifest(manifestUrls, "/solo/") : new Set();
    const mFrags = manifestOk ? slugsFromManifest(manifestUrls, "/solo/articles/") : new Set();

    // Candidate slugs to test on-disk existence
    const candidates = new Set([ ...site, ...mPages, ...mFrags ]);

    const diagBits = [
      manifestOk ? `manifest ok (${manifestUrls.length} URLs)` : "manifest missing/unreadable",
      sitemapOk ? `sitemap ok (${site.size} solo URLs)` : "sitemap missing/unreadable",
      `candidates: ${candidates.size}`
    ];
    setDiag(diagBits.join(" · "));

    if (candidates.size === 0) {
      // Nothing we can validate; show nothing else (issues-only screen).
      return;
    }

    // Verify on-disk presence for each slug
    const diskSolo = new Set();
    const diskFrag = new Set();
    await Promise.all(Array.from(candidates).map(async slug=>{
      const page = `/solo/${encodeURIComponent(slug)}.html`;
      const frag = `/solo/articles/${encodeURIComponent(slug)}.html`;
      if (await exists(page)) diskSolo.add(slug);
      if (await exists(frag)) diskFrag.add(slug);
    }));

    // Build per-slug matrix & collect issues
    const missing = {
      diskPage: new Set(),
      diskFrag: new Set(),
      sitemap:  new Set(),
      manifestPage: new Set(),
      manifestFrag: new Set(),
    };

    candidates.forEach(slug=>{
      if (!diskSolo.has(slug))      missing.diskPage.add(slug);
      if (!diskFrag.has(slug))      missing.diskFrag.add(slug);
      if (!site.has(slug))          missing.sitemap.add(slug);
      if (!mPages.has(slug))        missing.manifestPage.add(slug);
      if (!mFrags.has(slug))        missing.manifestFrag.add(slug);
    });

    const anyIssue = Object.values(missing).some(s => s.size);

    // Render issues
    if (missing.diskPage.size){
      const card = needCard("missing-disk-pages","Missing on disk: /solo/&lt;slug&gt;.html",
                            "These slugs do not resolve as full pages.", "red");
      const ol = card.querySelector("#missing-disk-pages-list");
      ol.innerHTML = "";
      Array.from(missing.diskPage).sort().forEach(slug=>{
        li(ol, `${fmt('/solo/'+slug+'.html')}`);
      });
      show(card);
    }
    if (missing.diskFrag.size){
      const card = needCard("missing-disk-frags","Missing on disk: /solo/articles/&lt;slug&gt;.html",
                            "These slugs do not resolve as fragments.", "red");
      const ol = card.querySelector("#missing-disk-frags-list");
      ol.innerHTML = "";
      Array.from(missing.diskFrag).sort().forEach(slug=>{
        li(ol, `${fmt('/solo/articles/'+slug+'.html')}`);
      });
      show(card);
    }
    if (missing.sitemap.size){
      const card = document.getElementById("pages-missing-sitemap") ||
                   needCard("pages-missing-sitemap","Full Pages missing from Sitemap",
                            "Present elsewhere but not in /solo/sitemap.xml.","yellow");
      const ol = card.querySelector("#list-pages-miss-sitemap") || card.querySelector("#pages-missing-sitemap-list");
      ol.innerHTML = "";
      Array.from(missing.sitemap).sort().forEach(slug=>{
        li(ol, `${fmt('/solo/'+slug+'.html')} → add to ${fmt('/solo/sitemap.xml')}`);
      });
      show(card);
      // If you want proposed XML, reuse your existing textarea builder here
    }
    if (missing.manifestPage.size || missing.manifestFrag.size){
      const card = needCard("missing-manifest","Missing in prefetch manifest",
                            "These URLs are not present in /precache-manifest.json.","yellow");
      const ol = card.querySelector("#missing-manifest-list");
      ol.innerHTML = "";
      Array.from(missing.manifestPage).sort().forEach(slug=>{
        li(ol, `${fmt('/solo/'+slug+'.html')} (page)`);
      });
      Array.from(missing.manifestFrag).sort().forEach(slug=>{
        li(ol, `${fmt('/solo/articles/'+slug+'.html')} (fragment)`);
      });
      show(card);
    }

    // Only green if NO issues and all four sources agree for every candidate
    if (!anyIssue) {
      const allClear = document.getElementById("all-clear");
      if (allClear) show(allClear);
    }
  }
})();
</script>
